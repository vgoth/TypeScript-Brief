# Основы

* Примитивные типы
* Типизация и использование массивов
* Тип any
* Типизация функций
* Типизация объектов
* Явное приведение типов
* Утверждение присваивания

TypeScript является надмножеством JavaScript и добавляет к языку возможности строгой типизации и конструкции объектно-ориентированного программирования для работы со сложными типами. Это повышает безопасность и эффективность разработки, улучшает качество кода, и дает возможность в полной мере использовать все преимущества ООП парадигмы.

На выходе компилятора (транспилятора) получаем валидный JavaScript код, из которого удалены все синтаксические конструкции (синтаксический сахар) TypeScript. Это позволяет писать код на чистом JavaScript до уровня спецификации ES6. Следовательно, для того, чтобы писать программы на TypeScript - необходимо, как минимум, знать основы JavaScript.

TypeScript поддерживает типизацию с поддержкой вывода типов. Компилятор автоматически выводит тип при первом присваивании переменной

```ts
let autoType;
autoType = 1;  // переменной 'autoType' присвоен тип number
```

> Допустимо писать код, вообще не определяя типы, полностью полагаясь на автоматическую типизацию компилятора. Только тогда возникает вопрос: зачем вы используете строго типизированный язык?..

TypeScript использует утиную типизацию, для вывода сложных типов переменных

```ts
let user = { id: 1, name: "John" };
user = { name: "Ethan", id: 2 };  // Допустимо, сработала утиная типизация
user = { id: 2 };  // Ошибка безопасности типов, отсутствует свойство 'name'
user = { name: "Ethan", pid: 2 };  // та же ошибка, у типа нет свойства 'pid'
```

TypeScript позволяет обращаться к строковым свойствам объекта с использованием точечной нотации

```ts
let stringObject = { "name": John };

console.log(stringObject["name"]) // John
console.log(stringObject.name)  // John
```

TypeScript проверяет наличие нулевых или неопределенных значений операндов, в операторах сложение, умножение, меньше чем, деление по модулю и степень. Компилятор всегда выполняет проверку, чтобы обе стороны операндов являлись действительными числами

```ts
let a = 1 + undefined; // Ошибка!
//  Оператор '+' нельзя применять к типам '1' и 'undefined'

let b = 1 * null; // Ошибка!
//  Объект имеет значение null
```

TypeScript включает в себя поддержку стандарта ECMAScript, позволяющего использовать подчеркивание `_` при определении больших чисел

```ts
let oneMillion = 1_000_000;
let limeGreenColor = 0x00_FF_00;

console.log(oneMillion);  // 1000000
console.log(limeGreenColor);  // 65280
```

## Примитивные типы

В TypeScript используются те же примитивные типы, что и в JavaScript: `string`, `number` и `boolean`.
> Типы, имена которых начинаются с заглавной буквы `String`, `Number`, `Boolean`, не рекомендуется использовать в TypeScript.

Синтаксис определения типа использует двоеточие `:` после имени переменной.
> Также применяют термин аннотация типа (Type Annotations).

```ts
let a: string = 'Apple';
let b: number = 10;
let c: boolean = true;
```

В дополнении к основным типам поддерживается новый базовый тип стандарта ECMAScript `bigint`. Чтобы компилятор распознал число такого типа, необходимо пометить его нотацией `n` в конце числа

```ts
let bigNumber: bigint = 9_007_199_254_740_991n + 1n;
```

> Что бы можно было использовать `bigint` тип, необходимо установить в качестве цели компилятора esnext или ES2020 в tsconfig.json. И учитывать, что не каждая среда исполнения JavaScript сможет его поддерживать.

## Типизация и использование массивов

Массив помечается нотацией `[]` после указания типа.

```ts
let arrayOfNum: number[]; // Массив чисел
arrayOfNum = [1, 2, 3];

let arrayOfString: string[] = ['John', 'Ethan', 'Jacob']; // Массив строк
```

или так, что тоже допустимо с использованием синтаксиса `обобщений` (Generics)

```ts
let arrayOfNum: Array<number>;
```

Циклы `for...in` и `for...of` используют синтаксис ES6 для перебора массива по ключу или значению.

```ts
for (key in arrayOfNum) {
  console.log(arrayOfNum[key]); // 1 2 3
}
```

или

```ts
for (val of arrayOfString) {
  console.log(vol); // John Ethan Jacob
}
```

## Тип any

Тип `any` отключает проверку типа

```ts
let anyType: any = 1;
anyType = 'one'; // переменной может быть присвоено значение любого типа
```

> Использование типа `any` считается плохой практикой и его следует применять с осторожностью. Лучшая практика - это использовать тип `unknown` или конструкцию языка `interface` для определения пользовательских типов.  
>Линтеры, при строгих настройках, выдают ошибку при использовании типа `any`.

## Типизация функций

Синтаксис типизации объявления функции требует определение типов ее параметров и возвращаемого значения.

```ts
function sum(a: number, b: number): number {
  return a + b;
}
```

Для параметров функций поддерживается автоматический вывод типов компилятором, если они явно не определены. Если тип параметра не указан, ему неявно присваивается тип `any`. То же происходит с типом возвращаемого значение функции. Компилятор попытается вывести тип из логики кода

```ts
function returnString(val) {
  return val.toString();
}
// компилятор выведет тип параметра 'val', как 'any',
// а возвращаемое значение типа 'string'
```

Если функция ничего не возвращает, используется тип `void`

```ts
function printUser(usr: string): void {
  console.log(`Hello ${usr}!`);
}
```

## Типизация объектов

Чтобы определить тип объекта, просто перечислите его свойства и их типы.

пример сигнатуры функции, которая принимает объект в своем аргументе

```ts
function printCoord(pt: { x: number; y: number }) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}
printCoord({ x: 3, y: 7 });
```

## Явное приведение типов

Объект может быть явно приведен к другому типу объекта с использованием нотации `<>` или `as` в правой части выражения.

```ts
let item = <any>{ id: 1, name: "John" };
item = { id: 2 }; // сработало, так как мы явно привели 'item' к типу 'any'
```

пример из реального использования

```ts
const header = document.getElementById("header") as HTMLElement;
```

## Утверждение присваивания

Восклицательный знак после имени переменной `!` - утверждение присваивания позволяет обращаться к переменной до ее инициализации

```ts
var globalStr: string;

initGlobalStr();  // По логике кода вызов функции инициализирует 'globalStr'

console.log(globalStr);  // Ошибка компиляции!
// Компилятор считает, что переменная не инициализирована
// перед использованием

function initGlobalStr() {
  globalStr = 'initialize';
}
```

есть два варианта, как поправить ситуацию

```ts
var globalString!: string;  // ! = утверждению, что переменная инициализирована
```

или так

```ts
console.log(globalString!);
```

> Утверждение присваивания не является хорошей практикой и его следует избегать. Если подобная проблема возникает, следует пересмотреть логику кода.
