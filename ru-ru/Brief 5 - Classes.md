# Классы

**Класс** - это определение формы объекта. Классы и интерфейсы основные строительные блоки объектно-ориентированной парадигмы программирования. В JavaScript конструкция класс представлена начиная со спецификации ECMAScript 6. TypeScript позволяет использовать классы и компилировать их в более ранние версии JavaScript, поддерживаемые любыми браузерами и платформами. Более того, в TypeScript классы поддерживают практически всю функциональность классического ООП, за небольшими исключениями налагаемыми особенностями самого JavaScript.

Типичный класс TypeScript

```ts
class SomeClass {
  a: number;  // Поле (переменная) класса

  constructor(arg: number) { // Конструктор (инициализатор) класса
    this.a = arg;  // 'this' - ссылка на экземпляр (объект) класса
  }

  print() { // Метод (функция) класса
    console.log(this.a);
  }
}

// Создаем экземпляр (объект) класса и инициализируем его свойство
// значением преданным как аргумент функции-конструктора
const someObject = new SomeClass(10);
someObject.print();  // 10

someObject.a = 5;
someObject.print();  // 5
```

> Чтобы исключить путаницу в терминах, в данном руководстве, переменная класса именуется **полем**, а применительно к объектам (экземплярам класса) - **свойством**.

## Поля класса

Свойства - это способ инкапсуляции данных внутри объекта. Объявляя поля класса, мы описываем общедоступные, записываемые свойства его экземпляров

```ts
class Coord {
  x: number;
  y: number;
  z: number;
}

const pos = new Coord();
pos.x = 0; pos.y = 0; pos.z = 0;
```

если попытаться скомпилировать этот код, то получим ошибку типа: **error TS2564: 'Свойства 'x/y/z' не инициализированы и не назначены в конструкторе'**. Компилятор всегда требует, чтобы все свойства объекта были установленны в допустимое значение до его использования. То есть проведена начальная инициализация. Чтобы поправить ситуацию, необходимо непосредственно установить значения полей класса и тогда компилятор автоматически инициализирует ими свойства экземпляров

```ts
class Coord {
  x = 0;
  // ...
}
```

> В данном примере тип поля компилятор выведет автоматически. Это хорошая практика: использовать типизацию там, где она явно необходима, не загромождая код излишней избыточностью.

или установить поля через конструктор класса

```ts
class Coord {
  x: number;
  // ...

  constructor(x: number, ...) {
    this.x = x;
    // ...
  }
}
```

> TypeScript не анализирует методы, вызываемые из конструктора, на предмет инициализации свойств. Это связано с тем, что сам конструктор может быть переопределен в производном классе. Поэтому проводить инициализацию поля необходимо непосредственно в самом конструкторе, по возможности не используя сторонние и внешние методы.

Иногда требуется обойти проверку инициализации свойств объекта. Для этого необходимо явно указать, что свойство может принимать тип `undefined`, используя объединение типов

```ts
class Coord {
  x: number | undefined;
  // ...
}
```

либо использовать утверждение присваивания, как в случае с переменной

```ts
class Coord {
  x!: number;
  // ...
}
```

Чтобы защитить свойство от изменения, применяют модификатор `readonly` к полю класса. В этом случае инициализировать свойство можно только непосредственной установкой значения поля или в конструкторе класса

```ts
class SomeClass {
  readonly a: number = 0;  // OK

  constructor(a: number) {
    this.a = a;  // OK
  }

  setToZero() {
    this.a = 0; // Ошибка! Свойство доступно только для чтения
  }
}

const someObject = new SomeClass(10);
someObject.a = 5;  // Ошибка! Свойство доступно только для чтения
```

> Обратите внимание на явное определение типа в объявлении поля! Дело в том, что модификатор `readonly`, фактически назначает константу класса. И если явно не указать тип, то неявно будет назначен тип литерала.
