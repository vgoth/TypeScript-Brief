# Классы

**Класс** - это определение формы объекта. Классы и интерфейсы основные строительные блоки объектно-ориентированной парадигмы программирования. В JavaScript конструкция класс представлена начиная со спецификации ECMAScript 6. TypeScript позволяет использовать классы и компилировать их в более ранние версии JavaScript, поддерживаемые любыми браузерами и платформами. Более того, в TypeScript классы поддерживают практически всю функциональность классического ООП, за небольшими исключениями налагаемыми особенностями самого JavaScript.

Типичный класс TypeScript

```ts
class SomeClass {
  a: number;  // Поле (переменная) класса

  constructor(arg: number) { // Конструктор (инициализатор) класса
    this.a = arg;  // 'this' - ссылка на экземпляр (объект) класса
  }

  print() { // Метод (функция) класса
    console.log(this.a);
  }
}

// Создаем экземпляр (объект) класса и инициализируем его свойство
// значением преданным как аргумент функции-конструктора
const someObject = new SomeClass(10);
someObject.print();  // 10

someObject.a = 5;
someObject.print();  // 5
```

> Чтобы исключить путаницу в терминах, в данном руководстве, переменная класса именуется **полем**, а применительно к объектам (экземплярам класса) - **свойством**.

## Поля класса

Свойства - это способ инкапсуляции данных внутри объекта. Объявляя поля класса, мы описываем общедоступные, записываемые свойства его экземпляров

```ts
class Coord {
  x: number;
  y: number;
}

const pos = new Coord();
pos.x = 0; pos.y = 0;
```

если попытаться скомпилировать этот код, то получим ошибку типа: **error TS2564: 'Свойства 'x/y' не инициализированы и не назначены в конструкторе'**. Компилятор всегда требует, чтобы все свойства объекта были установленны в допустимое значение до его использования. То есть проведена начальная инициализация. Чтобы поправить ситуацию, необходимо непосредственно установить значения полей класса и тогда компилятор автоматически инициализирует ими свойства экземпляров

```ts
class Coord {
  x = 0;
  // ...
}
```

> В данном примере тип поля компилятор выведет автоматически. Это хорошая практика: использовать типизацию там, где она явно необходима, не загромождая код излишней избыточностью.

или установить поля через конструктор класса

```ts
class Coord {
  x: number;
  // ...

  constructor(x: number, ...) {
    this.x = x;
    // ...
  }
}
```

> TypeScript не анализирует методы, вызываемые из конструктора, на предмет инициализации свойств. Это связано с тем, что сам конструктор может быть переопределен в производном классе. Поэтому проводить инициализацию поля необходимо непосредственно в самом конструкторе, по возможности не используя сторонние методы и внешние функции.

Иногда требуется обойти проверку инициализации свойств объекта. Для этого необходимо явно указать, что свойство может принимать тип `undefined`, используя объединение типов

```ts
class Coord {
  x: number | undefined;
  // ...
}
```

либо использовать утверждение присваивания `!`

```ts
class Coord {
  x!: number;
  // ...
}
```

Чтобы защитить свойство от изменения, применяют модификатор `readonly` к полю класса. В этом случае инициализировать свойство можно только непосредственной установкой значения поля или в конструкторе класса

```ts
class SomeClass {
  readonly a: number = 0;  // OK

  constructor(a: number) {
    this.a = a;  // OK
  }

  setToZero() {
    this.a = 0; // Ошибка! Свойство доступно только для чтения
  }
}

const someObject = new SomeClass(10);
someObject.a = 5;  // Ошибка! Свойство доступно только для чтения
```

> Обратите внимание на явное определение типа в объявлении поля! Дело в том, что модификатор `readonly`, фактически назначает константу класса. И если явно не указать тип, то неявно будет назначен тип литерала.

## Конструктор класса

Конструктор класса схож с обычными функциями и к нему применимы те же правила аннотации типа, за небольшим отличием. Конструктор не может иметь определения возвращаемого типа, возвращаемое значение - всегда тип экземпляра класса. В конструкторе нельзя использовать `обобщения` и передавать `параметр типа` (о обобщениях и параметрах типа в отдельном брифинге).

Конструктор с параметрами по умолчанию и остатка

```ts
class Coord {
  x: number;
  // ...

  constructor(x = 0, ...arg) {
    // ...
  }
}
```

Перегрузка конструктора для вызова с разными аргументами

```ts
class Coord {
  // ...

  constructor(x: number, y: number);
  constructor(s: string);
  constructor(xs: any, y?: any) {
    // ...
  }
}
```

## Методы класса

Методы класса - описывают свойства-функции его экземпляров. К методам применимы все правила типизации как и к обычным функциям.

```ts
class Coord {
  x = 1;
  y = 1;

  scale(n: number): void {
    this.x *= n;
    this.y *= n;
  }
  
  invert(): void {
    this.x *= -1;
    this.y *= -1;
  }

  print(): void {
    console.log(`X: ${this.x}, Y: ${this.y}`);
  }
}

const pos = new Coord();
pos.scale(.10);
pos.invert();
pos.print();  // X: -0.1, Y: -0.1
```

> Обратите внимание, что для доступа к полям и методам класса всегда используется `this`. Иначе, как и в JavaScript, поиск не найденного имени в теле метода, будет продолжен во внешней области видимости. За пределами класса.

## Аксессоры

Аксессоры (методы доступа к свойствам) - это просто функции, которые используются как пусковой механизм для связанной логики, установки `set` (сеттер) и получения `get` (геттер), значений полей класса. Аксессоры позволяют усилить инкапсуляцию, обеспечить дополнительную проверку и защиту данных. Но не отменяют возможности непосредственного обращения к свойствам объекта.

```ts
class Thing {
  _size = 0;  // Поле с которым работают аксессоры
 
  get size(): number {  // функция-геттер
    return this._size;  // возвращаем значение поля
  }
 
  set size(value: string | number | boolean) { // функция-сеттер*
    let num = Number(value);

    if (!Number.isFinite(num)) {
      this._size = 0; // инициируем поле значением
      return;
    }
 
    this._size = num; // и здесь ...
  }
}

const alien = new Thing();
alien.size = true;  // будет вызвана функция-сеттер, 'true' станет ее аргументом
console.log(alien.size);  // возврат значения через функцию-геттер

// Обращаемся к свойству напрямую в обход аксессоров
alien._size = 2;
console.log(alien._size);

// 1
// 2
```

> \* начиная с TypeScript 4.3 можно использовать разные типы в геттерах и сеттерах

## Наследование

TypeScript относится к типу языков, которые не поддерживают множественное наследование от нескольких классов, но позволяют классу реализовать множество интерфейсов.

Вспомним как наследуют (расширяют) интерфейсы

```ts
interface IBase {
  id: number;
  name: string;
}

interface IExtra {
  age: number;
}

interface IComplete extends IBase, IExtra {}
```

Используем ключевое слово `implements` после названия класса и перечислим через запятую интерфейсы, которые хотим реализовать

```ts
class Parent implements IBase, IExtra {
  // реализуем интерфейсы
  id: number;
  name: string;
  age: number;

  constructor(id: number, name: string, age: number) {
    this.id = id;
    // ...
  }
}
```

либо используя расширенный интерфейс из примера выше

```ts
class Parent implements IComplete {
  // ...
}
```

Ключевое слово `extends` указывает на класс от которого наследуем.

Наследуем от родительского класса и одновременно добавим классу-потомку поведение, имплементируя дополнительный интерфейс с методом

```ts
interface IBehavior {
  print(): void;  // описываем метод класса используя сигнатуру функции
}

// Унаследуем все свойства от класса Parent
class Child extends Parent implements IBehavior {
  // и реализуем метод интерфейса
  print() {
    console.log(this);
  }
}
```

> В терминологии ООП: поля класса обеспечивают состояние объекта. В то время как методы класса отвечают за его поведение.

## Переопределение методов

незакончен...
