# Классы

**Класс** - это определение формы объекта. Классы и интерфейсы основные строительные блоки объектно-ориентированной парадигмы программирования. В JavaScript конструкция класс представлена начиная со спецификации ECMAScript 6. TypeScript позволяет использовать классы и компилировать их в более ранние версии JavaScript, поддерживаемые любыми браузерами и платформами. Более того, в TypeScript классы поддерживают практически всю функциональность классического ООП, за небольшими исключениями налагаемыми особенностями самого JavaScript.

Типичный класс TypeScript

```ts
class SomeClass {
  a: number;  // Поле (переменная) класса

  constructor(arg: number) { // Конструктор (инициализатор) класса
    this.a = arg;  // 'this' - ссылка на экземпляр (объект) класса
  }

  print() { // Метод (функция) класса
    console.log(this.a);
  }
}

// Создаем экземпляр (объект) класса и инициализируем его свойство
// значением преданным как аргумент функции-конструктора
const someObject = new SomeClass(10);
someObject.print();  // 10

someObject.a = 5;
someObject.print();  // 5
```

> Чтобы исключить путаницу в терминах, в данном руководстве, переменная класса именуется **полем**, а применительно к объектам (экземплярам класса) - **свойством**.

## Поля класса

Свойства - это способ инкапсуляции данных внутри объекта. Объявляя поля класса, мы описываем общедоступные, записываемые свойства его экземпляров

```ts
class Coord {
  x: number;
  y: number;
}

const pos = new Coord();
pos.x = 0; pos.y = 0;
```

если попытаться скомпилировать этот код, то получим ошибку типа: *error TS2564: 'Свойства 'x/y' не инициализированы и не назначены в конструкторе'*. Компилятор всегда требует, чтобы все свойства объекта были установленны в допустимое значение до его использования. То есть проведена начальная инициализация. Чтобы поправить ситуацию, необходимо непосредственно установить значения полей класса и тогда компилятор автоматически инициализирует ими свойства экземпляров

```ts
class Coord {
  x = 0;
  // ...
}
```

> В данном примере тип поля компилятор выведет автоматически. Это хорошая практика: использовать типизацию там, где она явно необходима, не загромождая код излишней избыточностью.

или установить поля через конструктор класса

```ts
class Coord {
  x: number;
  // ...

  constructor(x: number, ...) {
    this.x = x;
    // ...
  }
}
```

Иногда требуется обойти проверку инициализации свойств объекта. Для этого необходимо явно указать, что свойство может принимать тип `undefined`, используя объединение типов

```ts
class Coord {
  x: number | undefined;
  // ...
}
```

либо использовать утверждение присваивания `!`

```ts
class Coord {
  x!: number;
  // ...
}
```

Чтобы защитить свойство от изменения, применяют модификатор `readonly` к полю класса. В этом случае инициализировать свойство можно только непосредственной установкой значения поля или в конструкторе класса

```ts
class SomeClass {
  readonly a: number = 0;  // OK

  constructor(a: number) {
    this.a = a;  // OK
  }

  setToZero() {
    this.a = 0; // Ошибка! Свойство доступно только для чтения
  }
}

const someObject = new SomeClass(10);
someObject.a = 5;  // Ошибка! Свойство доступно только для чтения
```

> Обратите внимание на явное определение типа в объявлении поля! Дело в том, что модификатор `readonly`, фактически назначает константу класса. И если явно не указать тип, то неявно будет назначен тип литерала.

## Конструктор класса

Конструктор класса схож с обычными функциями и к нему применимы те же правила аннотации типа, за небольшим отличием. Конструктор не может иметь определения возвращаемого типа, возвращаемое значение - всегда тип экземпляра класса. В конструкторе нельзя использовать `обобщения` и передавать `параметр типа` (о обобщениях и параметрах типа в отдельном брифинге).

Конструктор с параметрами по умолчанию и остатка

```ts
class Coord {
  x: number;
  // ...

  constructor(x = 0, ...arg) {
    // ...
  }
}
```

Перегрузка конструктора для вызова с разными аргументами

```ts
class Coord {
  // ...

  constructor(x: number, y: number);
  constructor(s: string);
  constructor(xs: any, y?: any) {
    // ...
  }
}
```

## Методы класса

Методы класса - описывают свойства-функции его экземпляров. К методам применимы все правила типизации как и к обычным функциям.

```ts
class Coord {
  x = 1;
  y = 1;

  scale(n: number): void {
    this.x *= n;
    this.y *= n;
  }
  
  invert(): void {
    this.x *= -1;
    this.y *= -1;
  }

  print(): void {
    console.log(`X: ${this.x}, Y: ${this.y}`);
  }
}

const pos = new Coord();
pos.scale(.10);
pos.invert();
pos.print();  // X: -0.1, Y: -0.1
```

> Обратите внимание, что для доступа к полям и методам класса всегда используется `this`. Иначе, как и в JavaScript, поиск не найденного имени в теле метода, будет продолжен во внешней области видимости. За пределами класса.

## Аксессоры

**Аксессоры** (методы доступа к свойствам) - это просто функции, которые используются как пусковой механизм для связанной логики, установки `set` (сеттер) и получения `get` (геттер) значений полей класса. Аксессоры позволяют усилить инкапсуляцию, обеспечить дополнительную проверку и защиту данных. Но не отменяют возможности непосредственного обращения к свойствам объекта.

```ts
class Thing {
  _size = 0;  // Поле с которым работают аксессоры
 
  get size(): number {  // функция-геттер
    return this._size;  // возвращаем значение поля
  }
 
  set size(value: string | number | boolean) { // функция-сеттер*
    let num = Number(value);

    if (!Number.isFinite(num)) {
      this._size = 0; // инициируем поле значением
      return;
    }
 
    this._size = num; // и здесь ...
  }
}

const alien = new Thing();
alien.size = true;  // будет вызвана функция-сеттер, 'true' станет ее аргументом
console.log(alien.size);  // возврат значения через функцию-геттер

// Обращаемся к свойству напрямую в обход аксессоров
alien._size = 2;
console.log(alien._size);

// 1
// 2
```

> \* начиная с TypeScript 4.3 можно использовать разные типы в геттерах и сеттерах

## Наследование

TypeScript относится к типу языков, которые не поддерживают множественное наследование от нескольких классов, но позволяют классу реализовать множество интерфейсов. TypeScript требует, чтобы производный класс всегда был подтипом своего базового класса, следовал контракту базового класса.

Вспомним как наследуют (расширяют) интерфейсы

```ts
interface IBase {
  id: number;
  name: string;
}

interface IExtra {
  age: number;
}

interface IComplete extends IBase, IExtra {}
```

Используем ключевое слово `implements` после названия класса и перечислим через запятую интерфейсы, которые хотим реализовать

```ts
class Base implements IBase, IExtra {
  // реализуем интерфейсы
  id: number;
  name: string;
  age: number;

  constructor(id: number, name: string, age: number) {
    this.id = id;
    // ...
  }
}
```

либо используя расширенный интерфейс из примера выше

```ts
class Base implements IComplete {
  // ...
}
```

Ключевое слово `extends` указывает на класс от которого наследуем.

Наследуем от родительского класса и одновременно добавим производному классу поведение, имплементируя дополнительный интерфейс с методом

```ts
interface IBehavior {
  print(): void;  // описываем метод класса используя сигнатуру функции
}

// Унаследуем все свойства от класса Base
class Derivative extends Base implements IBehavior {
  // и реализуем метод интерфейса
  print() {
    console.log(this);
  }
}
```

> В терминологии ООП: поля класса обеспечивают состояние объекта. В то время как методы класса отвечают за его поведение.

## Переопределение методов

При наследовании производный класс может переопределять методы базового (родительского) класса. Это применимо также к конструктору класса. Для доступа к методам и конструктору базового класса используется ключевое слово `super`. Обращение к родительскому классу всегда должно предшествовать использованию `this` в производном классе.

```ts
class Overloaded extends Derivative {
  gender: string;

  // Переопределяем конструктор
  constructor(id: number, name: string, age: number, gender = 'unknown') {
    // первым вызываем конструктор родительского класса
    super(id, name, age);
    // теперь можем обратиться к членам производного класса
    this.gender = gender;
  }

  // Переопределяем метод базового класса
  print(note?: string) {
    if (!note) {
      super.print();  // так вызываем родительский метод
    } else {
      console.log(this, note);
    }
  }
}
```

## Модификаторы доступа

Модификаторы доступа - это способ управления видимостью членов класса. TypeScript поддерживает следующие модификаторы доступа к полям и методам класса:

* `public` - полностью открытые, видимы в классе и вне класса;
* `protected` - доступные из производных классов, видны в классе и его потомках;
* `private` - закрытые для внешнего доступа, видимы только внутри класса, где были объявлены.

Все члены класса без модификатора доступа, по умолчанию считаются открытыми (public).

```ts
class Invisible {
  private _x = 1;
  protected y = 0;

  protected getX() {
    return this._x;  // OK
    // доступ к приватным членам разрешен внутри класса
  }
}

class Visibility extends Invisible {
  public y = 1;  // Законно
  // можем изменить видимость 'protected' из подкласса
  
  printX() {
    console.log(this.getX()); // ОК
    // доступ к защищенным членам разрешен из подкласса
  }
}

const m = new Invisible();
m._x = 3; // Ошибка! Доступ к приватным членам вне класса закрыт
console.log(m.getX()); // Ошибка! То же относиться к защищенным членам класса

const n = new Visibility();
n.y = 2; // OK
n.printX();  // 1
```

## Статические члены

Статические члены класса - это поля и методы, которые можно вызывать без необходимости создавать экземпляр класса. Доступ к ним можно получить через сам объект конструктора класса. Статические члены класса помечаются префиксом `static`, а для их вызова используют само имя класса.

Пример объявления и использования статического метода

```ts
class StaticPrint {
  static print(txt: string) { // пометили метод, как статический
    console.log(txt);
  }
}

// Обращаемся к статическому члену через имя класса
StaticPrint.print('Hey! Hey!'); // Hey! Hey!
```

Статическое поле порождает свойство в фактически глобальной области видимости, единое для всех экземпляров класса

```ts
class GlobalCount {
  static count = 0;

  increase() {
    GlobalCount.count++; // обращение к статическому члену внутри класса
  }
}

const firsCount = new GlobalCount();
const secondCount = new GlobalCount();

firsCount.increase();
console.log(GlobalCount.count);  // 1
secondCount.increase();
console.log(GlobalCount.count);  // 2
```

Статические члены могут использоваться совместно с модификаторами доступа

```ts
class SomeClass {
  private static x = 0;
}

console.log(SomeClass.x)  // Ошибка! Свойство доступно только в классе
```

и наследоваться

```ts
class Base {
  static greetings() {
    return 'Hey! Hey!';
  }
}
class Derivative extends Base {
  greetings = Derived.greetings();
}
```

> Поскольку классы JavaScript являются функциями которые можно вызывать с оператором `new`, есть зарезервированные слова которые нельзя применять в названии статических методов. Такие как `name`, `length`, `call`, ....

## Абстрактные классы

Классы, методы и поля в TypeScript могут быть абстрактными.

Абстрактный класс - это класс, который не предполагает создание экземпляров и предназначен для наследования другими классами, имеющими общую функциональность. Абстрактные классы похожи на интерфейсы, но в отличие от последних, могут иметь реализацию. Классы, которые не имеют абстрактных членов, в противовес абстрактным называют конкретными.

```ts
abstract class Person {
  id!: number;
  name!: string;

  abstract getPersonInfo (): string;
}

class ConcretePerson extends Person {
  // должны реализовать абстрактный метод в конкретном классе
  getPersonInfo() {
    return `ID: ${this.id}, Name: ${this.name}`;
  }
}

const usr = new Person(); // Ошибка! Нельзя создать экземпляр абстрактного класса
const usrConcrete = new ConcretePerson(); // ОК
```
